from time import sleep, time
from machine import I2C, Pin, ADC
from ht16k33 import HT16K33Matrix
import random

def jetzt_ms():
    return int(time() * 1000)

# ---- SPIEL-DAUER ----
GAME_DURATION_MS = 120000   # 2 Minuten

# ---- Joystick ----
vrx = ADC(Pin(3), atten=ADC.ATTN_11DB)
vry = ADC(Pin(4), atten=ADC.ATTN_11DB)

CENTER_X = 1940
CENTER_Y = 1895

DEADZONE = 200
MOVE_DELAY_MS = 120
SPEED_BOOST_DELAY_MS = 70

#----Display----
display = HT16K33Matrix(I2C(0))
display.set_angle(270)

#----Maps----
maps = [
    b"\x00\x66\x42\x58\x0b\x20\x6e\x00",
    b"\x00\x6e\x42\x10\x70\x06\x22\x30",
    b"\x10\x18\x4a\x63\x32\x00\x2c\x20",
    b"\x00\x46\x6c\x20\x22\x0a\x7a\x00"
]

#----Buttons----
button_red = Pin("A0", Pin.IN, Pin.PULL_UP)
button_blue = Pin("A1", Pin.IN, Pin.PULL_UP)

# ---------------------------------------------------------
# HILFSFUNKTIONEN
# ---------------------------------------------------------

def zufaelliger_spieler():
    return "Faenger" if random.random() < 0.5 else "Wegrenner"

def zufaellige_map():
    return random.choice(maps)

def zeige_startsequenz(meine_rolle):
    display.clear()
    display.scroll_text(f"Du bist: {meine_rolle}")
    sleep(0.6)
    display.scroll_text("Timer: 2.00min")
    sleep(0.6)

def kollision_wand(x, y, map_bytes):
    if x < 0 or x > 7 or y < 0 or y > 7:
        return True

    log_x = 7 - y
    log_y = x
    bit_mask = 1 << (7 - log_x)
    return (map_bytes[log_y] & bit_mask) != 0

def read_joystick_direction():
    x_raw = vrx.read()
    y_raw = vry.read()
    x_pos = x_raw - CENTER_X
    y_pos = y_raw - CENTER_Y

    if abs(x_pos) < DEADZONE and abs(y_pos) < DEADZONE:
        return None

    if abs(x_pos) > abs(y_pos):
        return "RIGHT" if x_pos > 0 else "LEFT"
    return "DOWN" if y_pos > 0 else "UP"

# ---- Spiral Animation ----
def spiral_close(display):
    coords = [
        (0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),
        (7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),
        (6,7),(5,7),(4,7),(3,7),(2,7),(1,7),(0,7),
        (0,6),(0,5),(0,4),(0,3),(0,2),(0,1),
        (1,1),(2,1),(3,1),(4,1),(5,1),(6,1),
        (6,2),(6,3),(6,4),(6,5),(6,6),
        (5,6),(4,6),(3,6),(2,6),(1,6),
        (1,5),(1,4),(1,3),(1,2),
        (2,2),(3,2),(4,2),(5,2),
        (5,3),(5,4),(5,5),
        (4,5),(3,5),(2,5),
        (2,4),(2,3),
        (3,3),(4,3),
        (4,4),(3,4)
    ]
    for x, y in coords:
        display.plot(x, y, 1)
        display.draw()
        sleep(0.03)

def zeige_ergebnis(rolle, gefangen):
    display.clear()
    sleep(0.2)
    if rolle == "Wegrenner":
        text = "Verloren" if gefangen else "Gewonnen!"
    else:
        text = "Gewonnen!" if gefangen else "Verloren"
    display.scroll_text(text)
    sleep(0.8)

def warte_auf_restart():
    display.clear()
    display.scroll_text("Beide Tasten")
    sleep(0.2)
    display.scroll_text("3s halten")
    sleep(0.2)

    timer = 0
    while True:
        if button_red.value() == 0 and button_blue.value() == 0:
            if timer == 0:
                timer = jetzt_ms()
            if jetzt_ms() - timer >= 3000:
                return
        else:
            timer = 0
        sleep(0.05)

# ---------------------------------------------------------
# HAUPT-SPIEL-FUNKTION
# ---------------------------------------------------------

def starte_spiel():
    global last_move_ms
    last_move_ms = 0

    # Spieler Start
    p1_x, p1_y = 7, 7
    p2_x, p2_y = 0, 0

    rolle = zufaelliger_spieler()
    karte = zufaellige_map()

    # Powerup
    used_red = 0
    used_blue = 0
    last_red = 1
    last_blue = 1
    invis = 0
    speed = 0

    zeige_startsequenz(rolle)
    game_start = jetzt_ms()

    # -------------------------------
    # LOOP
    # -------------------------------
    while True:
        jetzt = jetzt_ms()

        # TIMER
        if jetzt - game_start >= GAME_DURATION_MS:
            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=False)
            return

        # BUTTONS
        red = button_red.value()
        blue = button_blue.value()

        if last_red == 1 and red == 0 and used_red < 2:
            used_red += 1
            invis = jetzt + 3000

        if last_blue == 1 and blue == 0 and used_blue < 2:
            used_blue += 1
            speed = jetzt + 3000

        last_red = red
        last_blue = blue

        # Bewegung
        delay = SPEED_BOOST_DELAY_MS if jetzt < speed else MOVE_DELAY_MS
        richtung = read_joystick_direction()

        if richtung and (jetzt - last_move_ms) >= delay:
            nx, ny = p1_x, p1_y

            if richtung == "UP": ny -= 1
            elif richtung == "DOWN": ny += 1
            elif richtung == "LEFT": nx -= 1
            elif richtung == "RIGHT": nx += 1

            if not kollision_wand(nx, ny, karte):
                p1_x, p1_y = nx, ny

                if jetzt < speed:
                    # zweiter Schritt
                    nx2, ny2 = p1_x, p1_y
                    if richtung == "UP": ny2 -= 1
                    elif richtung == "DOWN": ny2 += 1
                    elif richtung == "LEFT": nx2 -= 1
                    elif richtung == "RIGHT": nx2 += 1
                    if not kollision_wand(nx2, ny2, karte):
                        p1_x, p1_y = nx2, ny2

            last_move_ms = jetzt

        # FANG ?
        if p1_x == p2_x and p1_y == p2_y:
            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=True)
            return

        # Render
        display.clear()
        display.set_icon(karte).draw()
        display.plot(p2_x, p2_y, 1)

        if jetzt >= invis:
            display.plot(p1_x, p1_y, 1)

        display.draw()
        sleep(0.02)

# ---------------------------------------------------------
# ENDLOSER GAME-LOOP MIT RESTART
# ---------------------------------------------------------

while True:
    starte_spiel()
    warte_auf_restart()
