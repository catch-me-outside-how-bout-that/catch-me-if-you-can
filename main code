from time import sleep, time
from machine import I2C, Pin
from ht16k33 import HT16K33Matrix
import random
import network
import espnow


startzeit = time()

def jetzt_ms():
    return int(time() * 1000)

# deine Timer-Variablen
unsichtbar_bis = 0
speed_boost_bis = 0

#----ESP-NOW----
###SLAVE_MAC = b'\x94\xb5\x55\xXX\xXX\xXX'   # ← MAC vom anderen Gerät eintragen

#wlan = WLAN(STA_IF)
#wlan.active(True)
#e = espnow.ESPNow()
#e.active(True)
###e.add_peer(SLAVE_MAC)

#----Display initialisieren----
display = HT16K33Matrix(I2C(0)) 
display.set_angle(270) 

#----Maps----
map1 = b"\x00\x66\x42\x58\x0b\x20\x6e\x00"
map2 = b"\x00\x6e\x42\x10\x70\x06\x22\x30"
map3 = b"\x10\x18\x4a\x63\x32\x00\x2c\x20"
map4 = b"\x00\x46\x6c\x20\x22\x0a\x7a\x00"
maps = [map1, map2, map3, map4]

#----Startpunkt----
P1_START_X, P1_START_Y = 7, 7    # links oben
P2_START_X, P2_START_Y = 0, 0    # rechts unten

p1_x, p1_y = P1_START_X, P1_START_Y
p2_x, p2_y = P2_START_X, P2_START_Y

#----Button einfügen----
button_red = Pin("A0", Pin.IN, Pin.PULL_UP) 
button_blue = Pin("A1", Pin.IN, Pin.PULL_UP)

#----Powerups-Zustand----
max_use = 2
used_red = 0
used_blue = 0
#Zustand speichern um zu sehen ob Button gedrückt wurde
last_used_red = 1
last_used_blue = 1

#----Funktionen----
def zufaelliger_spieler():
  if random.random() < 0.5:
    meine_rolle = "Faenger"
    gegner_rolle = "Wegrenner"
  else:
    meine_rolle = "Wegrenner"
    gegner_rolle = "Faenger"
    
  ###e.send(SLAVE_MAC, "ROLLE:" + gegner_rolle)
  return meine_rolle

def zufaellige_map():
  gewaelte_map = random.choice(maps)
  ###e.send(SLAVE_MAC, "MAP:" + gewaelte_map.hex())
  return gewaelte_map

def zeige_startsequenz(meine_rolle):
  display.clear()
  display.scroll_text(f"Du bist: {meine_rolle}")
  sleep(1)
  display.scroll_text("Timer: 2.00 min")
  sleep(1)

#Prüfen ob Position eine Wand ist (1) oder frei (0) -> Bit 0 = linke Spalte
def kollision_wand(x,y, gewaehlte_map):
  if x < 0 or x > 7 or y < 0 or y > 7: #definiert wo Spielrand ist
    return True
  byte_index = y # Zeile 0 = Byte 0, Zeile 1 = Byte 1,...
  bit_mask = 1 << (7-x) # Bit 0 = Spalte 7, Bit 7 = Spalte 0
  return (gewaelte_map[byte_index] & bit_mask) != 0

def reset_powerups():
    #Powerups für neues Spiel zurücksetzen
    global uses_red, uses_blue
    uses_red = 0
    uses_blue = 0

def zeichnen():
  meine_rolle = zufaelliger_spieler()
  gewaehlte_map = zufaellige_map()
  zeige_startsequenz(meine_rolle)

  #Map zeichnen
  display.clear()
  display.set_icon(gewaehlte_map).draw()

  #Spieler-Punkte
  display.plot(p1_x, p1_y, 1)   # 1 = an, mit .plot kann man über map zeichen ohne sie zu überschreiben
  display.plot(p2_x, p2_y, 1)

  display.draw()
  return gewaehlte_map

zeichnen()

#----Hauptspiel-Loop----

#Wandkollision
while True:
  aktuell_ms = jetzt_ms()
  
  #x_val = vrx.read()   # 0–4095
  #y_val = vry.read()

  #neue_x = mein_x
  #neue_y = mein_y

  #nur bewegen, wenn Zielfeld frei
  #if neue_x != mein_x or neue_y != mein_y:
    #if not kollision_wand(neue_x, neue_y):  # Keine Wand?
          #mein_x, mein_y = neue_x, neue_y     #bewegen

#Button-Abfragen
  current_red = button_red.value() #1 = nicht gedrückt , 0 = gedrückt
  current_blue = button_blue.value()

#red button - unsichtbar
  if last_used_red == 1 and current_red == 0 and used_red < max_use: #Button wurde gedrückt
    used_red += 1
    unsichtbar_bis = aktuell_ms + 3000 #3 sek.
    display.plot(p1_x, p1_y, 0)   
            
  #blue button - Speed-Boost
  if last_used_blue == 1 and current_blue == 0 and used_blue < max_use:
    used_blue += 1
    speed_boost_bis = aktuell_ms + 3000 #3 sek.

  last_blue = current_blue

  # Spieler zeichnen: Wenn unsichtbar, nicht zeichnen; sonst normal oder blinken
  display.plot(p1_x, p1_y, 0)  # erstmal löschen (für Update)
  display.plot(p2_x, p2_y, 1)  # P2 immer zeichnen
    
  if aktuell_ms < unsichtbar_bis:
      # Unsichtbar: nichts zeichnen für P1
      pass
  elif aktuell_ms < speed_boost_bis:
      # Speed-Boost aktiv: Blinken als Placeholder (da Speed noch nicht implementiert)
      for blink in range(10):
          display.plot(p1_x, p1_y, 0)
          display.draw()
          sleep(0.05)
          display.plot(p1_x, p1_y, 1)
          display.draw()
          sleep(0.05)
  else:
      # Normal zeichnen
      display.plot(p1_x, p1_y, 1)
  
  display.draw()
