# board1_game_with_espnow.py  (Master / Game-ESP32)
from time import sleep, time
from machine import I2C, Pin, ADC
from ht16k33 import HT16K33Matrix
import random
import network
import espnow
import ujson

def jetzt_ms():
    return int(time() * 1000)

# ---- SPIEL-DAUER ----
GAME_DURATION_MS = 120000   # 2 Minuten

# ---- Joystick (nur lokal für Player1)----
vrx = ADC(Pin(3), atten=ADC.ATTN_11DB)
vry = ADC(Pin(4), atten=ADC.ATTN_11DB)

CENTER_X = 1940
CENTER_Y = 1895

DEADZONE = 200
MOVE_DELAY_MS = 120
SPEED_BOOST_DELAY_MS = 70

#----Display----
display = HT16K33Matrix(I2C(0))
display.set_angle(270)

#----Maps----
maps = [
    b"\x00\x66\x42\x58\x0b\x20\x6e\x00",
    b"\x00\x6e\x42\x10\x70\x06\x22\x30",
    b"\x10\x18\x4a\x63\x32\x00\x2c\x20",
    b"\x00\x46\x6c\x20\x22\x0a\x7a\x00"
]

#----Buttons----
button_red = Pin("A0", Pin.IN, Pin.PULL_UP)
button_blue = Pin("A1", Pin.IN, Pin.PULL_UP)

# ---------------------------------------------------------
# ESP-NOW Setup (MASTER)
# ---------------------------------------------------------
w = network.WLAN(network.STA_IF)
w.active(True)

e = espnow.ESPNow()
e.active(True)

# <-- TRAGE HIER DIE MAC-ADRESSE VON BOARD 2 (PEER) EIN !!!
# Beispiel: peer_mac = b'\xac\x67\xb2\x1f"\x81'
peer_mac = b'H\xcaC/\x08\x14'  # <-- ERSETZT
try:
    e.add_peer(peer_mac)
except Exception as err:
    # falls noch nicht erreichbar - add_peer kann fehlschlagen, handle still
    print("add_peer:", err)

# ---------------------------------------------------------
# Hilfsfunktionen aus deinem Code (leicht angepasst)
# ---------------------------------------------------------
def zufaelliger_spieler():
    return "Faenger" if random.random() < 0.5 else "Wegrenner"

def zufaellige_map_index():
    return random.randrange(len(maps))

def zeige_startsequenz(meine_rolle):
    display.clear()
    display.scroll_text(f"Du bist: {meine_rolle}")
    sleep(0.6)
    display.scroll_text("Timer: 2.00min")
    sleep(0.6)

def kollision_wand(x, y, map_bytes):
    if x < 0 or x > 7 or y < 0 or y > 7:
        return True
    log_x = 7 - y
    log_y = x
    bit_mask = 1 << (7 - log_x)
    return (map_bytes[log_y] & bit_mask) != 0

def read_joystick_direction():
    x_raw = vrx.read()
    y_raw = vry.read()
    x_pos = x_raw - CENTER_X
    y_pos = y_raw - CENTER_Y
    if abs(x_pos) < DEADZONE and abs(y_pos) < DEADZONE:
        return None
    if abs(x_pos) > abs(y_pos):
        return "RIGHT" if x_pos > 0 else "LEFT"
    return "DOWN" if y_pos > 0 else "UP"

# ---- Spiral Animation ---- (unchanged)
def spiral_close(display):
    coords = [
        (0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),
        (7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),
        (6,7),(5,7),(4,7),(3,7),(2,7),(1,7),(0,7),
        (0,6),(0,5),(0,4),(0,3),(0,2),(0,1),
        (1,1),(2,1),(3,1),(4,1),(5,1),(6,1),
        (6,2),(6,3),(6,4),(6,5),(6,6),
        (5,6),(4,6),(3,6),(2,6),(1,6),
        (1,5),(1,4),(1,3),(1,2),
        (2,2),(3,2),(4,2),(5,2),
        (5,3),(5,4),(5,5),
        (4,5),(3,5),(2,5),
        (2,4),(2,3),
        (3,3),(4,3),
        (4,4),(3,4)
    ]
    for x, y in coords:
        display.plot(x, y, 1)
        display.draw()
        sleep(0.03)

def zeige_ergebnis(rolle, gefangen):
    display.clear()
    sleep(0.2)
    if rolle == "Wegrenner":
        text = "Verloren" if gefangen else "Gewonnen!"
    else:
        text = "Gewonnen!" if gefangen else "Verloren"
    display.scroll_text(text)
    sleep(0.8)

def warte_auf_restart():
    display.clear()
    display.scroll_text("Beide Tasten")
    sleep(0.2)
    display.scroll_text("3s halten")
    sleep(0.2)
    timer = 0
    while True:
        if button_red.value() == 0 and button_blue.value() == 0:
            if timer == 0:
                timer = jetzt_ms()
            if jetzt_ms() - timer >= 3000:
                return
        else:
            timer = 0
        sleep(0.05)

# ---------------------------------------------------------
# ESP-NOW: eingehende Nachrichten verarbeiten
# Erwartetes Paket vom Peer (Board2): {"dx": -1/0/1, "dy": -1/0/1, "red":0/1, "blue":0/1}
# ---------------------------------------------------------
# Zustand/Timer für Player2 (auf MASTER)
last_move_ms_p1 = 0
last_move_ms_p2 = 0
used_red_p1 = used_blue_p1 = 0
used_red_p2 = used_blue_p2 = 0
invis_p1 = 0
speed_p1 = 0
invis_p2 = 0
speed_p2 = 0

# Empfangspuffer für letzten Input von Peer
peer_input = {"dx":0,"dy":0,"red":0,"blue":0, "ts":0}

def handle_incoming():
    """
    Call often in the main loop — non-blocking check for incoming ESP-NOW packets.
    """
    global peer_input
    # e.recv() returns (mac, msg) when a message is present
    recv = e.recv()
    if not recv:
        return
    try:
        host, msg = recv
        if not msg:
            return
        # msg is bytes, decode and parse JSON
        data = ujson.loads(msg.decode())
        # store the last input with timestamp
        data["ts"] = jetzt_ms()
        peer_input = data
    except Exception as err:
        print("espnow recv error:", err)

def send_state(p1_x, p1_y, p2_x, p2_y, rolle, map_index, remaining_ms):
    """
    send the authoritative state to the peer so it can render locally.
    """
    payload = {
        "type": "state",
        "p1_x": p1_x,
        "p1_y": p1_y,
        "p2_x": p2_x,
        "p2_y": p2_y,
        "role_for_peer": "Faenger" if rolle == "Wegrenner" else "Wegrenner",
        "map_index": map_index,
        "remaining_ms": remaining_ms
    }
    try:
        e.send(peer_mac, ujson.dumps(payload))
    except Exception as err:
        # Peer not reachable / not added yet - ignore
        # print("espnow send error:", err)
        pass

def send_start(map_index, role_for_peer):
    payload = {"type":"start", "role_for_peer": role_for_peer, "map_index": map_index, "start_ts": jetzt_ms()}
    try:
        e.send(peer_mac, ujson.dumps(payload))
    except Exception:
        pass

# ---------------------------------------------------------
# HAUPT-SPIEL-FUNKTION (angepasst: behandelt p2 Input vom Peer)
# ---------------------------------------------------------
def starte_spiel():
    global last_move_ms_p1, last_move_ms_p2
    global used_red_p1, used_blue_p1, used_red_p2, used_blue_p2
    global invis_p1, invis_p2, speed_p1, speed_p2

    last_move_ms_p1 = 0
    last_move_ms_p2 = 0

    # Spieler Start
    p1_x, p1_y = 7, 7
    p2_x, p2_y = 0, 0

    rolle = zufaelliger_spieler()
    map_index = zufaellige_map_index()
    karte = maps[map_index]

    # Powerup
    used_red_p1 = 0
    used_blue_p1 = 0
    used_red_p2 = 0
    used_blue_p2 = 0
    invis_p1 = 0
    invis_p2 = 0
    speed_p1 = 0
    speed_p2 = 0

    zeige_startsequenz(rolle)

    # Sende Start-Paket an Peer (teilt Map und Rolle für Peer mit)
    # rolle_for_peer = rolle inverted: if I am Faenger, peer is Wegrenner
    rolle_for_peer = "Faenger" if rolle == "Wegrenner" else "Wegrenner"
    send_start(map_index, rolle_for_peer)

    game_start = jetzt_ms()
    last_state_send = 0

    # -------------------------------
    # LOOP
    # -------------------------------
    while True:
        jetzt = jetzt_ms()

        # TIMER
        remaining = max(0, GAME_DURATION_MS - (jetzt - game_start))
        if jetzt - game_start >= GAME_DURATION_MS:
            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=False)
            return

        # ----- Handle incoming ESP-NOW packets (peer input) -----
        handle_incoming()

        # BUTTONS (local P1)
        red = button_red.value()
        blue = button_blue.value()

        if used_red_p1 is None:
            used_red_p1 = 0
        if used_blue_p1 is None:
            used_blue_p1 = 0

        # detect rising edge (pressed = 0)
        # local P1 button logic
        if red == 0 and used_red_p1 < 2 and hasattr(starte_spiel, "__pressed_last_red_p1") == False:
            pass  # handled below with edge detection
        # We implement edge detection with last values stored as attributes
        if not hasattr(starte_spiel, "__last_red_p1"):
            starte_spiel.__last_red_p1 = 1
            starte_spiel.__last_blue_p1 = 1

        if starte_spiel.__last_red_p1 == 1 and red == 0 and used_red_p1 < 2:
            used_red_p1 += 1
            invis_p1 = jetzt + 3000

        if starte_spiel.__last_blue_p1 == 1 and blue == 0 and used_blue_p1 < 2:
            used_blue_p1 += 1
            speed_p1 = jetzt + 3000

        starte_spiel.__last_red_p1 = red
        starte_spiel.__last_blue_p1 = blue

        # ----- Peer button/input handling -> update p2 state -----
        # peer_input contains last known dx,dy,red,blue,ts
        if peer_input and peer_input.get("ts", 0) > 0:
            # edge detection for peer buttons (simple)
            # For used counters and timers for p2 we track last states
            if not hasattr(starte_spiel, "__last_red_p2"):
                starte_spiel.__last_red_p2 = 1
                starte_spiel.__last_blue_p2 = 1

            px = peer_input.get("dx", 0)
            py = peer_input.get("dy", 0)
            # buttons are 1 when pressed in sender convention
            red_p = peer_input.get("red", 0)
            blue_p = peer_input.get("blue", 0)

            # button edge
            if starte_spiel.__last_red_p2 == 0 and red_p == 1 and used_red_p2 < 2:
                # (case where sender uses different convention) - try both:
                used_red_p2 += 1
                invis_p2 = jetzt + 3000
            # handle if sender reports 1 while pressed:
            if starte_spiel.__last_red_p2 == 1 and red_p == 1 and used_red_p2 < 2:
                # this means sender uses 1==pressed; only trigger on transition 0->1 if possible
                # simpler: trigger when value is 1 and not already active (cooldown limit ensures no spam)
                if invis_p2 < jetzt:
                    used_red_p2 += 1
                    invis_p2 = jetzt + 3000

            if starte_spiel.__last_blue_p2 == 0 and blue_p == 1 and used_blue_p2 < 2:
                used_blue_p2 += 1
                speed_p2 = jetzt + 3000
            if starte_spiel.__last_blue_p2 == 1 and blue_p == 1 and used_blue_p2 < 2:
                if speed_p2 < jetzt:
                    used_blue_p2 += 1
                    speed_p2 = jetzt + 3000

            starte_spiel.__last_red_p2 = red_p
            starte_spiel.__last_blue_p2 = blue_p

            # Bewegung für p2 based on peer dx/dy, obeying move delay and boost delay
            delay_p2 = SPEED_BOOST_DELAY_MS if jetzt < speed_p2 else MOVE_DELAY_MS
            if (jetzt - last_move_ms_p2) >= delay_p2:
                nx2, ny2 = p2_x + px, p2_y + py
                if not kollision_wand(nx2, ny2, karte):
                    p2_x, p2_y = nx2, ny2
                    # if boosted, do second step
                    if jetzt < speed_p2:
                        nx22, ny22 = p2_x + px, p2_y + py
                        if not kollision_wand(nx22, ny22, karte):
                            p2_x, p2_y = nx22, ny22
                last_move_ms_p2 = jetzt

        # ----- Bewegung P1 (lokal) -----
        delay = SPEED_BOOST_DELAY_MS if jetzt < speed_p1 else MOVE_DELAY_MS
        richtung = read_joystick_direction()
        if richtung and (jetzt - last_move_ms_p1) >= delay:
            nx, ny = p1_x, p1_y
            if richtung == "UP": ny -= 1
            elif richtung == "DOWN": ny += 1
            elif richtung == "LEFT": nx -= 1
            elif richtung == "RIGHT": nx += 1
            if not kollision_wand(nx, ny, karte):
                p1_x, p1_y = nx, ny
                if jetzt < speed_p1:
                    nx2, ny2 = p1_x, p1_y
                    if richtung == "UP": ny2 -= 1
                    elif richtung == "DOWN": ny2 += 1
                    elif richtung == "LEFT": nx2 -= 1
                    elif richtung == "RIGHT": nx2 += 1
                    if not kollision_wand(nx2, ny2, karte):
                        p1_x, p1_y = nx2, ny2
            last_move_ms_p1 = jetzt

        # ----- FANG ? -----
        if p1_x == p2_x and p1_y == p2_y:
            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=True)
            return

        # ----- Render -----
        display.clear()
        display.set_icon(karte).draw()

        # p2 always visible on display
        display.plot(p2_x, p2_y, 1)
        # p1 is hidden if invis active
        if jetzt >= invis_p1:
            display.plot(p1_x, p1_y, 1)

        display.draw()
        sleep(0.02)

        # ----- Periodically send authoritative state to peer -----
        if jetzt - last_state_send >= 150:
            send_state(p1_x, p1_y, p2_x, p2_y, rolle, map_index, remaining)
            last_state_send = jetzt

# ---------------------------------------------------------
# ENDLOSER GAME-LOOP MIT RESTART
# ---------------------------------------------------------
while True:
    starte_spiel()
    warte_auf_restart()
