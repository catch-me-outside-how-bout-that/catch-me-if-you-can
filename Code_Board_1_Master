from time import sleep, time
from machine import Pin, ADC
import neopixel
import random
import network
import espnow
import ujson

def jetzt_ms():
    return int(time() * 1000)

# ---- SPIEL-DAUER ----
GAME_DURATION_MS = 120000   # 2 Minuten

# ---- Joystick (lokaler Spieler P1) ----
vrx = ADC(Pin(3), atten=ADC.ATTN_11DB)
vry = ADC(Pin(4), atten=ADC.ATTN_11DB)

# ---- JOYSTICK AUTOKALIBRATION ----
sleep(0.5)
samples_x = []
samples_y = []
for _ in range(20):
    samples_x.append(vrx.read())
    samples_y.append(vry.read())
    sleep(0.02)

CENTER_X = sum(samples_x) // len(samples_x)
CENTER_Y = sum(samples_y) // len(samples_y)

DEADZONE = 150
print("CENTER_X:", CENTER_X, "CENTER_Y:", CENTER_Y)

MOVE_DELAY_MS = 120
SPEED_BOOST_DELAY_MS = 70

# ---------------------------------------------------------
# NEOPIXEL 8x8 MATRIX
# ---------------------------------------------------------

class NeoPixelMatrix8x8:
    def __init__(self, pin_name="D5", width=8, height=8, base_brightness=0.25):
        self.width = width
        self.height = height
        self.base_brightness = base_brightness
        pin = Pin(pin_name, Pin.OUT)
        self.np = neopixel.NeoPixel(pin, width * height)
        self.buffer = [(0, 0, 0)] * (width * height)

    def _index(self, x, y):
        """
        Logische Koordinaten:
        x: 0..7 (links -> rechts)
        y: 0..7 (oben -> unten)

        Hardware-Layout:
        - Index 0 unten links
        - l√§uft Reihe f√ºr Reihe von unten nach oben
        - jeweils von links nach rechts

        Dadurch ist das Board nicht mehr gespiegelt.
        """
        if not (0 <= x < self.width and 0 <= y < self.height):
            return None
        row_from_bottom = 7 - y   # y=7 -> row 0 (unten), y=0 -> row 7 (oben)
        col_from_left = x         # x=0 -> links
        return row_from_bottom * self.width + col_from_left

    def clear(self):
        for i in range(self.width * self.height):
            self.buffer[i] = (0, 0, 0)

    def draw(self):
        """
        Schreibt den Buffer auf die Matrix.
        Limitiert die Gesamthelligkeit so, dass effektiv
        max. ~15 LEDs auf Vollgas entsprechen.
        """
        lit = 0
        for (r, g, b) in self.buffer:
            if r or g or b:
                lit += 1

        scale_lit = 1.0
        if lit > 15:
            scale_lit = 15.0 / float(lit)

        for i, (r, g, b) in enumerate(self.buffer):
            br = self.base_brightness * scale_lit
            self.np[i] = (int(r * br), int(g * br), int(b * br))
        self.np.write()

    def plot(self, x, y, val=1, color=(40, 40, 40)):
        idx = self._index(x, y)
        if idx is None:
            return
        if val:
            self.buffer[idx] = color
        else:
            self.buffer[idx] = (0, 0, 0)

    def set_icon(self, map_bytes, color=(20, 20, 0)):
        """
        Zeichnet die W√§nde analog zu kollision_wand().
        Darstellung & Kollision stimmen √ºberein.
        """
        self.clear()
        for x in range(8):
            for y in range(8):
                if not (0 <= x <= 7 and 0 <= y <= 7):
                    continue
                if kollision_wand(x, y, map_bytes):
                    self.plot(x, y, 1, color)
        return self

    def fill(self, color):
        for i in range(self.width * self.height):
            self.buffer[i] = color

# ---- 5V-Levelshift f√ºr G0-Port aktivieren ----
level_shift = Pin("D4", Pin.OUT)
level_shift.on()

#----Display (NeoPixel)----
display = NeoPixelMatrix8x8(pin_name="D5")

#----Maps----
maps = [
    b"\x00\x66\x42\x58\x0b\x20\x6e\x00",
    b"\x00\x6e\x42\x10\x70\x06\x22\x30",
    b"\x10\x18\x4a\x63\x32\x00\x2c\x20",
    b"\x00\x46\x6c\x20\x22\x0a\x7a\x00"
]

#----Buttons----
button_red = Pin("A0", Pin.IN, Pin.PULL_UP)
button_blue = Pin("A1", Pin.IN, Pin.PULL_UP)

# ---------------------------------------------------------
# ESP-NOW SETUP (MASTER)
# ---------------------------------------------------------
w = network.WLAN(network.STA_IF)
w.active(True)

e = espnow.ESPNow()
e.active(True)

# HIER: MAC-ADRESSE VON BOARD 2 EINTRAGEN!
peer_mac = b'H\xcaC/\x08\x14'
try:
    e.add_peer(peer_mac)
except Exception as err:
    print("add_peer:", err)

# Empfangspuffer f√ºr Board-2-Input
p2_dir = None
p2_red = 0
p2_blue = 0

# ---------------------------------------------------------
# HILFSFUNKTIONEN
# ---------------------------------------------------------

def zufaelliger_spieler():
    return "Faenger" if random.random() < 0.5 else "Wegrenner"

def zufaellige_map_index():
    return random.randrange(len(maps))

def zeige_startsequenz(meine_rolle):
    """
    Ersetzt den Scroll-Text durch eine Rollen-Animation:
    - Faenger: rotes Schachbrett
    - Wegrenner: blaues Schachbrett
    plus kurzer "Timer"-Blink.
    """
    display.clear()
    # F√§nger = blau, Wegrenner = rot
    color = (0, 0, 80) if meine_rolle == "Faenger" else (80, 0, 0)

    # Schachbrett-Animation
    for phase in range(4):
        display.clear()
        for x in range(8):
            for y in range(8):
                if (x + y + phase) % 2 == 0:
                    display.plot(x, y, 1, color)
        display.draw()
        sleep(0.12)

    # Startposition kurz anzeigen
    display.clear()
    if meine_rolle == "Faenger":
        display.plot(7, 7, 1, color)
    else:
        display.plot(0, 0, 1, color)
    display.draw()
    sleep(0.5)

    # kurzes "Timer"-Blink
    for _ in range(2):
        display.fill((20, 20, 20))
        display.draw()
        sleep(0.15)
        display.clear()
        display.draw()
        sleep(0.15)

    display.clear()
    display.draw()

def kollision_wand(x, y, map_bytes):
    if x < 0 or x > 7 or y < 0 or y > 7:
        return True
    log_x = 7 - y
    log_y = x
    bit_mask = 1 << (7 - log_x)
    return (map_bytes[log_y] & bit_mask) != 0

def read_joystick_direction():
    x_raw = vrx.read()
    y_raw = vry.read()
    x_pos = x_raw - CENTER_X
    y_pos = y_raw - CENTER_Y

    if abs(x_pos) < DEADZONE and abs(y_pos) < DEADZONE:
        return None

    if abs(x_pos) > abs(y_pos):
        return "RIGHT" if x_pos > 0 else "LEFT"
    else:
        return "DOWN" if y_pos > 0 else "UP"

# ---- Spiral Animation ----
def spiral_close(display_obj):
    coords = [
        (0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),
        (7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),
        (6,7),(5,7),(4,7),(3,7),(2,7),(1,7),(0,7),
        (0,6),(0,5),(0,4),(0,3),(0,2),(0,1),
        (1,1),(2,1),(3,1),(4,1),(5,1),(6,1),
        (6,2),(6,3),(6,4),(6,5),(6,6),
        (5,6),(4,6),(3,6),(2,6),(1,6),
        (1,5),(1,4),(1,3),(1,2),
        (2,2),(3,2),(4,2),(5,2),
        (5,3),(5,4),(5,5),
        (4,5),(3,5),(2,5),
        (2,4),(2,3),
        (3,3),(4,3),
        (4,4),(3,4)
    ]
    display_obj.clear()
    for x, y in coords:
        display_obj.plot(x, y, 1, color=(0, 40, 0))
        display_obj.draw()
        sleep(0.03)

def zeige_ergebnis(rolle, gefangen):
    """
    Ersetzt den Text "Gewonnen/Verloren" durch Farb-Blink:
    - Gewonnen: gr√ºn blinkend
    - Verloren: rot blinkend
    """
    if rolle == "Wegrenner":
        gewonnen = not gefangen
    else:
        gewonnen = gefangen

    col = (0, 60, 0) if gewonnen else (60, 0, 0)

    display.clear()
    display.draw()
    sleep(0.2)

    for _ in range(4):
        display.fill(col)
        display.draw()
        sleep(0.25)
        display.clear()
        display.draw()
        sleep(0.2)

def warte_auf_restart():
    """
    Wartet, bis beide Buttons 3s gehalten werden.
    Animation: pulsierender Rahmen.
    """
    timer = 0
    on = False

    while True:
        on = not on
        display.clear()
        if on:
            col = (8, 8, 8)
            # Rahmen zeichnen
            for x in range(8):
                display.plot(x, 0, 1, col)
                display.plot(x, 7, 1, col)
            for y in range(1, 7):
                display.plot(0, y, 1, col)
                display.plot(7, y, 1, col)
        display.draw()

        if button_red.value() == 0 and button_blue.value() == 0:
            if timer == 0:
                timer = jetzt_ms()
            if jetzt_ms() - timer >= 3000:
                return
        else:
            timer = 0

        sleep(0.2)

# ---------------------------------------------------------
# ESP-NOW: eingehende INPUTS von Board 2
# ---------------------------------------------------------
def handle_incoming():
    global p2_dir, p2_red, p2_blue
    try:
        mac, msg = e.recv(0)   # 0 = non-blocking
    except OSError:
        return
    if not msg:
        return
    try:
        data = ujson.loads(msg.decode())
    except:
        return

    if isinstance(data, dict) and data.get("type") == "input":
        p2_dir = data.get("dir", None)
        p2_red = data.get("red", 0)
        p2_blue = data.get("blue", 0)

# ---------------------------------------------------------
# ESP-NOW: State an Board 2
# ---------------------------------------------------------
def send_state(p1_x, p1_y, p2_x, p2_y, rolle, map_index, remaining_ms):
    payload = {
        "type": "state",
        "p1_x": p1_x,
        "p1_y": p1_y,
        "p2_x": p2_x,
        "p2_y": p2_y,
        "role_for_peer": "Faenger" if rolle == "Wegrenner" else "Wegrenner",
        "map_index": map_index,
        "remaining_ms": remaining_ms
    }
    try:
        e.send(peer_mac, ujson.dumps(payload))
    except:
        pass

def send_start(map_index, rolle_fuer_peer):
    payload = {
        "type": "start",
        "role_for_peer": rolle_fuer_peer,
        "map_index": map_index,
        "start_ts": jetzt_ms()
    }
    try:
        e.send(peer_mac, ujson.dumps(payload))
    except:
        pass

# ---------------------------------------------------------
# HAUPT-SPIEL-FUNKTION (mit P2 √ºber ESP-NOW)
# ---------------------------------------------------------

def starte_spiel():
    global p2_dir

    # Spieler Start
    p1_x, p1_y = 7, 7
    p2_x, p2_y = 0, 0

    rolle = zufaelliger_spieler()
    map_index = zufaellige_map_index()
    karte = maps[map_index]

    # Powerup (nur f√ºr P1)
    used_red = 0
    used_blue = 0
    last_red = 1
    last_blue = 1
    invis = 0
    speed = 0

    p2_dir = None
    last_move_p1 = 0
    last_move_p2 = 0

    zeige_startsequenz(rolle)

    # Infos an Board 2 schicken
    rolle_fuer_peer = "Faenger" if rolle == "Wegrenner" else "Wegrenner"
    send_start(map_index, rolle_fuer_peer)

    game_start = jetzt_ms()
    last_state_send = 0

    # -------------------------------
    # LOOP
    # -------------------------------
    while True:
        jetzt = jetzt_ms()

        # TIMER abgelaufen?  SEND GAME OVER
        if jetzt - game_start >= GAME_DURATION_MS:

            won = False if rolle == "Faenger" else True
            game_over_packet = {"type": "game_over", "won": won}
            try:
                e.send(peer_mac, ujson.dumps(game_over_packet))
            except:
                pass

            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=False)
            return

        remaining = GAME_DURATION_MS - (jetzt - game_start)

        # INPUT von Board 2
        handle_incoming()

        # BUTTONS P1 (Powerups)
        red = button_red.value()
        blue = button_blue.value()

        if last_red == 1 and red == 0 and used_red < 2:
            used_red += 1
            invis = jetzt + 3000

        if last_blue == 1 and blue == 0 and used_blue < 2:
            used_blue += 1
            speed = jetzt + 3000

        last_red = red
        last_blue = blue

        # Bewegung P1
        delay_p1 = SPEED_BOOST_DELAY_MS if jetzt < speed else MOVE_DELAY_MS
        richtung_p1 = read_joystick_direction()

        if richtung_p1 and (jetzt - last_move_p1) >= delay_p1:
            nx, ny = p1_x, p1_y

            if richtung_p1 == "UP": ny -= 1
            elif richtung_p1 == "DOWN": ny += 1
            elif richtung_p1 == "LEFT": nx -= 1
            elif richtung_p1 == "RIGHT": nx += 1

            if not kollision_wand(nx, ny, karte):
                p1_x, p1_y = nx, ny

                if jetzt < speed:
                    nx2, ny2 = p1_x, p1_y
                    if richtung_p1 == "UP": ny2 -= 1
                    elif richtung_p1 == "DOWN": ny2 += 1
                    elif richtung_p1 == "LEFT": nx2 -= 1
                    elif richtung_p1 == "RIGHT": nx2 += 1
                    if not kollision_wand(nx2, ny2, karte):
                        p1_x, p1_y = nx2, ny2

            last_move_p1 = jetzt

        # Bewegung P2
        if p2_dir and (jetzt - last_move_p2) >= MOVE_DELAY_MS:
            nx2, ny2 = p2_x, p2_y

            if p2_dir == "UP": ny2 -= 1
            elif p2_dir == "DOWN": ny2 += 1
            elif p2_dir == "LEFT": nx2 -= 1
            elif p2_dir == "RIGHT": nx2 += 1

            if not kollision_wand(nx2, ny2, karte):
                p2_x, p2_y = nx2, ny2

            last_move_p2 = jetzt

        # FANG? üîµ SEND GAME OVER
        if p1_x == p2_x and p1_y == p2_y:

            won = True if rolle == "Faenger" else False
            game_over_packet = {"type": "game_over", "won": won}
            try:
                e.send(peer_mac, ujson.dumps(game_over_packet))
            except:
                pass

            spiral_close(display)
            zeige_ergebnis(rolle, gefangen=True)
            return

        # Render
        display.set_icon(karte, color=(15, 15, 0))  # W√§nde

        # Spielerfarben: F√§nger = blau, Wegrenner = rot
        if rolle == "Faenger":
            # P1 ist F√§nger, P2 ist Wegrenner
            p1_color = (0, 0, 60)   # F√§nger (du) = blau
            p2_color = (60, 0, 0)   # Wegrenner = rot
        else:
            # P1 ist Wegrenner, P2 ist F√§nger
            p1_color = (60, 0, 0)   # Wegrenner (du) = rot
            p2_color = (0, 0, 60)   # F√§nger = blau

        # P2 immer sichtbar
        display.plot(p2_x, p2_y, 1, color=p2_color)

        # P1 nur sichtbar, wenn Unsichtbarkeit abgelaufen
        if jetzt >= invis:
            display.plot(p1_x, p1_y, 1, color=p1_color)

        display.draw()

        # State an Board 2 schicken
        if jetzt - last_state_send >= 150:
            send_state(p1_x, p1_y, p2_x, p2_y, rolle, map_index, remaining)
            last_state_send = jetzt

        sleep(0.02)

# ---------------------------------------------------------
# ENDLOSER GAME-LOOP MIT RESTART
# ---------------------------------------------------------

while True:
    starte_spiel()
    warte_auf_restart()
