# combined_game_with_joystick.py
from time import sleep, time
from machine import I2C, Pin, ADC
from ht16k33 import HT16K33Matrix
import random
import math

startzeit = time()
def jetzt_ms():
    return int(time() * 1000)

# ---- Joystick (VRX = GPIO4, VRY = GPIO3) ----
# Verwende deine bestätigten Pins:
vrx = ADC(Pin(3), atten=ADC.ATTN_11DB)   # left/right
vry = ADC(Pin(4), atten=ADC.ATTN_11DB)   # up/down

# Falls du die Mitte neu kalibrieren willst, benutze die Funktion weiter unten.
CENTER_X = 1940   # aus Deinem Dozenten-Code
CENTER_Y = 1895

DEADZONE = 200          # Rohwert-Deadzone (anpassen falls zu groß/klein)
MOVE_DELAY_MS = 150     # Grund-Delay zwischen Bewegungen
SPEED_BOOST_DELAY_MS = 70  # Delay während Speed-Boost

last_move_ms = 0
last_direction = None    # um "Ruckeln" zu reduzieren / optional Edge-detection

#----ESP-NOW----
# (auskommentiert / placeholder)
# SLAVE_MAC = b'\x94\xb5\x55\xXX\xXX\xXX'

#----Display initialisieren----
display = HT16K33Matrix(I2C(0))
display.set_angle(270)

#----Maps----
map1 = b"\x00\x66\x42\x58\x0b\x20\x6e\x00"
map2 = b"\x00\x6e\x42\x10\x70\x06\x22\x30"
map3 = b"\x10\x18\x4a\x63\x32\x00\x2c\x20"
map4 = b"\x00\x46\x6c\x20\x22\x0a\x7a\x00"
maps = [map1, map2, map3, map4]

#----Startpunkt----
P1_START_X, P1_START_Y = 7, 7    # links oben
P2_START_X, P2_START_Y = 0, 0    # rechts unten

p1_x, p1_y = P1_START_X, P1_START_Y
p2_x, p2_y = P2_START_X, P2_START_Y

#----Button einfügen----
button_red = Pin("A0", Pin.IN, Pin.PULL_UP)
button_blue = Pin("A1", Pin.IN, Pin.PULL_UP)

#----Powerups-Zustand----
max_use = 2
used_red = 0
used_blue = 0
# Zustand speichern um zu sehen ob Button gedrückt wurde (last state)
last_used_red = 1
last_used_blue = 1

# Timer-Variablen
unsichtbar_bis = 0
speed_boost_bis = 0

#----Hilfsfunktionen----
def zufaelliger_spieler():
    if random.random() < 0.5:
        meine_rolle = "Faenger"
        gegner_rolle = "Wegrenner"
    else:
        meine_rolle = "Wegrenner"
        gegner_rolle = "Faenger"

    # e.send(SLAVE_MAC, "ROLLE:" + gegner_rolle)
    return meine_rolle

def zufaellige_map():
    gewaelte_map = random.choice(maps)
    # e.send(SLAVE_MAC, "MAP:" + gewaelte_map.hex())
    return gewaelte_map

def zeige_startsequenz(meine_rolle):
    display.clear()
    display.scroll_text(f"Du bist: {meine_rolle}")
    sleep(1)
    display.scroll_text("Timer: 2.00 min")
    sleep(1)

# Prüfen ob Position eine Wand ist (1) oder frei (0)
# Bit 0 = linke Spalte (in deinem Schema Bit 0 == Spalte 7, deshalb Masken so wie vorher)
def kollision_wand(phys_x, phys_y, map_bytes):
    # Spielfeldgrenzen prüfen
    if phys_x < 0 or phys_x > 7 or phys_y < 0 or phys_y > 7:
        return True

    # 270°-Rotation rückgängig machen → physX,Y → logX,Y
    log_x = 7 - phys_y
    log_y = phys_x

    # Bit aus Map lesen
    bit_mask = 1 << (7 - log_x)
    return (map_bytes[log_y] & bit_mask) != 0

def reset_powerups():
    global used_red, used_blue
    used_red = 0
    used_blue = 0

# Optional: kalibrierfunktion (einmal ausführen, wenn Joystick ruhig in Mittelstellung)
def measure_center(samples=200, delay=0.005):
    sx = 0
    sy = 0
    for _ in range(samples):
        sx += vrx.read()
        sy += vry.read()
        sleep(delay)
    cx = sx // samples
    cy = sy // samples
    return cx, cy

# Zeichnen/Initiales Setup
def zeichnen():
    global p1_x, p1_y
    meine_rolle = zufaelliger_spieler()
    gewaehlte_map = zufaellige_map()
    zeige_startsequenz(meine_rolle)

    display.clear()
    display.set_icon(gewaehlte_map).draw()

    # Spieler-Punkte
    display.plot(p1_x, p1_y, 1)
    display.plot(p2_x, p2_y, 1)
    display.draw()

    return gewaehlte_map

gewaehlte_map = zeichnen()

# ---- Helfer: Richtung aus Joystick (Axis + Deadzone + Dominant-Axis) ----
def read_joystick_direction():
    # Rohwerte
    x_raw = vrx.read()
    y_raw = vry.read()

    # Zentrieren
    x_pos = x_raw - CENTER_X
    y_pos = y_raw - CENTER_Y

    # Deadzone: wenn beides in Deadzone => None
    if abs(x_pos) < DEADZONE and abs(y_pos) < DEADZONE:
        return None, x_pos, y_pos

    # Dominante Achse entscheidet die Richtung (verhindert diagonale)
    if abs(x_pos) > abs(y_pos):
        # horizontale Bewegung
        if x_pos > 0:
            return "RIGHT", x_pos, y_pos
        else:
            return "LEFT", x_pos, y_pos
    else:
        # vertikale Bewegung
        if y_pos > 0:
            return "DOWN", x_pos, y_pos
        else:
            return "UP", x_pos, y_pos

# ---- Hauptspiel-Loop ----
while True:
    aktuell_ms = jetzt_ms()

    # --------------------
    # Buttons (Red = Unsichtbar, Blue = Speed)
    # --------------------
    current_red = button_red.value()    # 1 = nicht gedrückt , 0 = gedrückt
    current_blue = button_blue.value()

    # red button - unsichtbar
    if last_used_red == 1 and current_red == 0 and used_red < max_use:
        used_red += 1
        unsichtbar_bis = aktuell_ms + 3000  # 3 sek.
        # Beim unsichtbar-aktivieren Pixel ausblenden (wird unten berücksichtigt)

    # blue button - Speed-Boost
    if last_used_blue == 1 and current_blue == 0 and used_blue < max_use:
        used_blue += 1
        speed_boost_bis = aktuell_ms + 3000  # 3 sek.

    # update last states
    last_used_red = current_red
    last_used_blue = current_blue

    # --------------------
    # Joystick -> Bewegung (rate-limited)
    # --------------------
    # Compute current delay (faster when speed boost active)
    if aktuell_ms < speed_boost_bis:
        move_delay = SPEED_BOOST_DELAY_MS
    else:
        move_delay = MOVE_DELAY_MS

    direction, x_pos, y_pos = read_joystick_direction()

    can_move_now = (aktuell_ms - last_move_ms) >= move_delay

    if direction is not None and can_move_now:
        neue_x = p1_x
        neue_y = p1_y

        if direction == "UP":
            neue_y = p1_y - 1
        elif direction == "DOWN":
            neue_y = p1_y + 1
        elif direction == "LEFT":
            neue_x = p1_x - 1
        elif direction == "RIGHT":
            neue_x = p1_x + 1

        # Prüfen ob Feld frei (keine Wand)
        if not kollision_wand(neue_x, neue_y, gewaehlte_map):
            # if speed boost active, try a second step (if still free)
            p1_x, p1_y = neue_x, neue_y
            if aktuell_ms < speed_boost_bis:
                # zweiter Schritt
                zweite_x = p1_x
                zweite_y = p1_y
                if direction == "UP":
                    zweite_y = p1_y - 1
                elif direction == "DOWN":
                    zweite_y = p1_y + 1
                elif direction == "LEFT":
                    zweite_x = p1_x - 1
                elif direction == "RIGHT":
                    zweite_x = p1_x + 1

                if not kollision_wand(zweite_x, zweite_y, gewaehlte_map):
                    p1_x, p1_y = zweite_x, zweite_y

            last_move_ms = aktuell_ms

    # --------------------
    # Zeichnen (Map + Spieler)
    # --------------------
    # Map zeichnen (Icon bereits gezeichnet, aber safe-Redraw: clear + icon)
    display.clear()
    display.set_icon(gewaehlte_map).draw()

    # Spieler anzeigen: P2 immer sichtbar
    display.plot(p2_x, p2_y, 1)

    # P1: Unsichtbar oder normal / blink placeholder (wie zuvor)
    if aktuell_ms < unsichtbar_bis:
        # unsichtbar: nicht zeichnen P1
        pass
    elif aktuell_ms < speed_boost_bis:
        # Speed-Boost: blink placeholder (kurzes Blink-Feedback)
        # Ein leichteres Blink-Verhalten als zuvor, nur einmal pro Loop um CPU zu schonen
        display.plot(p1_x, p1_y, 1)
        # optional: could add more fancy effect
    else:
        display.plot(p1_x, p1_y, 1)

    display.draw()

    # kleine Pause, Schleifen-Granularität
    sleep(0.02)
